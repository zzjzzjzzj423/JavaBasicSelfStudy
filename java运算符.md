1. 关于OperationBasic的getNumber方法， 有一个比较统一的公式可以得到个， 十， 百， 千等等， n/位数（个位-1， 十位-10等等）%10
2. 取值范围： byte(1字节)<short（2字节）<int（4字节）<long（8字节）< float(4字节)<double(8字节)，
   2.1 为什么long是8字节， 但是取值范围是-2^63 到2^63-1?
   因为64位中有一位是符号位， 其中0是正数， 1为负数， 正数从0开始， 负数从-1开始， 所以正数要减去1， 且指数都是63
   2.2 为什么明明float的字节数小于long，但是float取值范围大于long？
   因为计算机中小数都是由三个部分组成 符号位（1）+指数位（8）+尾数位（23）， 因为可以通过指数部分通过127的偏移量动态调控数字大小， 从而也能表示很小的数如 指数为-126的数很小很小， 所以float的取值范围大于long。
3. 隐式转换 规则：
   3.1 取值范围小的先转化为取值范围大的， 再进行计算
   3.2 byte short char 先转化为int类型进行计算
4. 强制转换
   4.1. 什么时候强制转换？： 取值范围大的->取值范围小的
   4.2 格式： 目标数据类型=（目标数据类型）待强转类型
5. 字符串运算：当+中出现字符串时候即"" 那么此时+不再是运算符了而是字符串连接符号如"123"+123="123123"
6. 逻辑运算符号：
<img width="1456" height="501" alt="image" src="https://github.com/user-attachments/assets/ce379475-8957-4fc3-9a12-1672acf189e0" />

7. 短路逻辑运算符：即当左边有明确结果后， 右边无需执行 例如 a&&b 如果a对才会看后面
8. 原码， 反码和补码：
   8.1： 原码第一位为符号位
   8.2： 反码是符号位不变其他0->1, 1->0 然后正数的反码不变。
       8.2.1： 为什么正数的反码不变， 因为反码是为了解决负数的加法所创造出来的， 而正数的加法不会有问题， 所以正数的反码不用改变。
       8.2.2： 
