1. Static： 是java中的一个修饰符， 既可以修饰成员变量又可以修饰成员方法

  1.1 静态变量： 该类的所有的对象共享这个变量, 静态变量在JDK8以后位于堆内存的静态区， 而静态变量可以由Class调用所有他是优于对象的出现的

  1.2 静态方法： 该类的所有的对象共享这个方法， 多用于测试类和工具类

      1.2.1 工具类将构造私有化并且方法全部设置为静态方法

      1.2.2 静态方法的注意事项：

      1.2.2.1 静态方法只能访问静态方法和静态变量， 为什么？

      因为静态方法是共享的是伴随类产生的， 而倘若可以访问成员变量便会导致混乱，而且也会泄露没有意义

      1.2.2.2 静态方法没有this关键字

2. 继承关系：

    2.1 提高代码复用性

    2.2 可以让子类在父类基础上添加功能

    如何设计？

    满足1.在类与类之间存在相同内容而且2.子类是父类的一种

    2.3 Java只能单继承， 不能多继承但是支持多层继承即A继承B， B继承C， 其中C是A的间接父类， 其中每一个类都间接或直接继承于Object

    2.4 子类只能调用public成员变量和放法

    2.5 子类可以继承什么？

    构造方法                          非私有 不能                                        private 不能

    成员变量                           非私有 能                                         private 能

    成员方法                           非私有 能                                         private 不能

    2.6 为什么构造方法不能被继承

      因为倘若可以被继承， 违背构造方法， 方法名与类名不同

    2.7 继承内存分布

      子内载入方法区后， 检测到有父类从而父类也开辟方法区。 最在在堆区会有两块空间， 一部分放父类一部分子类

      2.7.1 成员方法的继承

        a. 虚方法表：如果父类的方法是非final， 非static， 非private的那么父类会把它们放到虚方法表中再往下继承会一直传递给各个子类从而加快效率调用

        b. 层级检测： 如果当前父类没有这个方法会一直往下进行查看， 知道找到这个方法

    2.8 继承的特点

      2.8.1 继承中成员变量的特点：就近原则即局部位置->成员位置（this）->父类位置（super）

      2.8.2 继承中成员方法的特点： 先查看本类是否有方法如果没有前往父类寻找即就近原则

        2.8.2.1 当父类方法无法满足需求， 子类可以进行方法重写@Override（本质是子类覆盖了虚方法中的方法）

          a. 重写方法的名称、形参列表必须与父类中的一致。

          b. 子类重写父类方法时,访问权限子类必须大于等于父类

          c. 子类重写父类方法时,返回值类型子类必须小于等于父类, 比如父类是A， 子类是B， 然后A中某一个方法返回B类型然后， 子类返回大小也只能是B，假若A中某一个方法返回A类型那么子类大小可以是A或B

          d. 建议:重写的方法尽量和父类保持一致。

          e. 只有被添加到虚方法表中的方法才能被重写

      2.8.3 父类构造方法的特点

        2.8.3.1 构造方法无法继承， 但是子类创建时， 一定会先调用父类的无参构造进行创建

        2.8.3.1 如果想要手动进行父类有参构造可以进行由Super（）进行重写

3. this和super的详解

  3.1 this就是一个局部变量， 当前方法调用者的地址值

  3.2 super就是一个局部变量， 当前方法调用者父类的存储空间

4.多态

  4.1 同类型对象表现出不同形式即 father f=new son1（）

  4.2 多态的前提：

    a. 有继承关系

    b. 有父类引用指向子类对象

    c. 有方法重写

  4.3 多态的调用

    
    口诀：编译看左边， 运行看左边
    a. 成员变量

        如animal a=new Dog(); 而打印其中的name属性时， 假若在animal和Dog中均有name属性， 那么会打印animal中的name， 因为Java中成员变量是静态绑定的， 所以animal类型即会打印animal的name

    口诀： 编译看左边， 运行看右边
    b. 成员方法

         如animal a=new Dog(); 当调用show（）方法时，  假若在animal和Dog中均有show方法， 且Dog对show（）进行了重写， 因为虚方法表中重写会覆盖， 所以会调用Dog中的show（）方法

    4.4 多态优点：

      4.4.1  解耦合， 便于拓展和维护

      4.4.2 定义方法的时候以父类作为参数类型， 既可以将子类传入， 体现了拓展性

    为什么只能由父类被赋值成子类不可以反过来？

    这其实与隐式转换有关， 在之前我们知道隐式转换只能小等于大， 而在继承关系的父与子中， 父类是小于子类的， 所以不能反过来

    如果如animal a=new Dog(); （弊端，多态中不能使用特有功能）其中我想要调用Dog中的方法， 但是会报错因为编译看左边， 运行看右边， 那该怎么解决？

      这种情况我们可以通过强转来解决， 值得一提判断一个变量是否是一直类型， 如果是就强转可以用 instanceof  其中 a instance of Dog d  代表的含义就是先判断a是否是Dog类型如果是强转为d


5.  导包的规则
    
    使用同一个包中的类时,不需要导包。

    使用java.lang包中的类时,不需要导包。

    其他情况都需要导包

    如果同时使用两个包中的同名类,需要用全类名。


6. final

    可以修饰类（不能被继承）， 



    方法（不能被重写）， 



    变量（常量）:

    引用数据类型： 地址值不可变， 所存值可变

    基本数据类型： 值不可改变

7. 权限类型

修饰符    同一 个类中    同一个包中其他类    不同包下的子类  不同包下的无关类

private      √ 

空着不写       √             √ 

protected     √              √                  √ 

public        √              √                   √              √


8. 代码块

  8.1 局部代码块

  8.2 构造代码块： 构造方法中重复的代码写在构造代码块中

  8.3 静态代码快： 和构造代码块相似的写法， 需要加static{}， 随着类加载指向， 且只执行一次

9. 抽象类与抽象方法

  9.1 抽象方法： 把子类共有的的方法提取出来且父类不能确定子类该方法的逻辑， 就可以定义为抽象方法。

  抽象方法的定义格式： abstract 返回值 方法名（）;

  9.2 抽象类： 如果一个类含有一个抽象方法， 那么这个类就叫做抽象类

  抽象类的定义格式; abstract class 类名（）;

    9.2.1    抽象类可以有构造方法， 抽象类不能实例化， 抽象类不一定有抽象方法。

10. 接口： 接口是一种行为， 接口是一种规则

  10.1 接口中成员的特点

    ● 成员变量：只能是常量，默认修饰符:public static final
    
    ● 构造方法：没有

    ● 成员方法： 只能是抽象方法，默认修饰符:public abstract

    ●JDK7以前:接口中只能定义抽象方法。

    ●JDK8的新特性:接口中可以定义有方法体的方法。(默认、静态)

      ● 允许在接口中定义默认方法,需要使用关键字default修饰，作用:解决接口升级的问题

        接口中默认方法的定义格式:
          ● 格式:public default 返回值类型 方法名(参数列表){}
          ● 范例:public default void show(){ }

        接口中默认方法的注意事项:
            
          ● 默认方法不是抽象方法,所以不强制被重写。但是如果被重写,重写的时候去掉default关键字

          ●public可以省略,default不能省略

          ● 如果实现了多个接口,多个接口中存在相同名字的默认方法,子类就必须对该方法进行重写

      ●允许在接口中定义定义静态方法,需要用static修饰

        接口中静态方法的定义格式:

          ● 格式:public static返回值类型 方法名(参数列表){}

          ● 范例:public static void show(){}

        接口中静态方法的注意事项:

          ● 静态方法只能通过接口名调用,不能通过实现类名或者对象名调用

          ● public可以省略,static不能省略

    ●JDK9的新特性:接口中可以定义私有方法。作用提取默认方法中的公共代码

      接口中私有方法的定义格式:

        ● 格式1:private,返回值类型 方法名(参数列表){}

        ● 范例1:private void show(){}

        ● 格式2: private static 返回值类型 方法名(参数列表){}

        ● 范例2:private static void method(){}

  10.2 如果多个接口有重名方法只用实现一次

  10.3 接口和接口的关系： 可以单继承可以多继承

11. 总结， 类与接口的关系：

  11.1 类与类的关系： 可以单继承， 可以多层继承， 不可多继承

    11.1.1 为什么不可以多继承？  这是为了避免钻石问题， b，c 两个类继承与a， 假如d可以继承与b，c。 而a中有一个方法foo（）  当d.foo()的时候不知道调用那个继承路径， 从而造成二义性。

  11.2 类与接口的关系， 实现关系， 可以多实现， 可以单实现

  11.3 接口与接口的关系， 继承关系， 可以多继承， 可以单继承， 可以多层继承

12 设计模式

  12.1 适配者模式， 如果有一个接口有很多方法需要实现， 但是我只需要其中几个功能， 我可以构造一个适配器类去实现这个接口其中这个接口重写其余空实现，再后继承这个适配器类即可。

    如果这个类需要继承其他的类该怎么办， 可以让中间件adaptor间接继承即可。

13. 内部类

  13.1 什么是内部类?

    在一个类的里面,再定义一个类。

    举例: 在A类的内部定义B类,B类就被称为内部类

    public class Quter {
      public class Inner {

      }

    }

  13.2 为什么要内部类？因为内部类单独出现没有意义

  13.3 内部类的规则： 

    a. 当内部类单独出现没有意义且内部类是外部内的一部分。

    b. 内部类可以调用外部类的成员方法，成员变量包括private

    c. 当外部类想要调用内部类的成员变量， 方法的时候需要创建对象。包括私有

    为什么private可以访问？

      嵌套类和外部类互为“同一个顶层类型”的一部分。

  13.4 内部类的分类
      
    a. 成员内部类 属于外部类成员的类， 内部类对象中有个隐藏的外部类对象this值 调用便是Outer.this

    b. 静态内部类, 成员内部类 static

    c. 局部内部类

    d. 匿名内部类

      1. 什么是匿名内部类?
      隐藏了名字的内部类,可以写在成员位置,也可以写在局部位置。
      
      2. 匿名内部类的格式?
      
      new 类名或者接口名(){
      重写方法;
      
      };
      
      3. 格式的细节
      
      包含了继承或实现,方法重写,创建对象。
      整体就是一个类的子类对象或者接口的实现类对象
      
      4. 使用场景
      
      当方法的参数是接口或者类时,
      以接口为例,可以传递这个接口的实现类对象,
      如果实现类只要使用一次,就可以用匿名内部类简化代码。

      
