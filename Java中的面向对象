1. Static： 是java中的一个修饰符， 既可以修饰成员变量又可以修饰成员方法

  1.1 静态变量： 该类的所有的对象共享这个变量, 静态变量在JDK8以后位于堆内存的静态区， 而静态变量可以由Class调用所有他是优于对象的出现的

  1.2 静态方法： 该类的所有的对象共享这个方法， 多用于测试类和工具类

      1.2.1 工具类将构造私有化并且方法全部设置为静态方法

      1.2.2 静态方法的注意事项：

      1.2.2.1 静态方法只能访问静态方法和静态变量， 为什么？

      因为静态方法是共享的是伴随类产生的， 而倘若可以访问成员变量便会导致混乱，而且也会泄露没有意义

      1.2.2.2 静态方法没有this关键字

2. 继承关系：

    2.1 提高代码复用性

    2.2 可以让子类在父类基础上添加功能

    如何设计？

    满足1.在类与类之间存在相同内容而且2.子类是父类的一种

    2.3 Java只能单继承， 不能多继承但是支持多层继承即A继承B， B继承C， 其中C是A的间接父类， 其中每一个类都间接或直接继承于Object

    2.4 子类只能调用public成员变量和放法

    2.5 子类可以继承什么？

    构造方法                          非私有 不能                                        private 不能

    成员变量                           非私有 能                                         private 能

    成员方法                           非私有 能                                         private 不能

    2.6 为什么构造方法不能被继承

      因为倘若可以被继承， 违背构造方法， 方法名与类名不同

    2.7 继承内存分布

      子内载入方法区后， 检测到有父类从而父类也开辟方法区。 最在在堆区会有两块空间， 一部分放父类一部分子类

      2.7.1 成员方法的继承

        a. 虚方法表：如果父类的方法是非final， 非static， 非private的那么父类会把它们放到虚方法表中再往下继承会一直传递给各个子类从而加快效率调用

        b. 层级检测： 如果当前父类没有这个方法会一直往下进行查看， 知道找到这个方法

    2.8 继承的特点

      2.8.1 继承中成员变量的特点：就近原则即局部位置->成员位置（this）->父类位置（super）

      2.8.2 继承中成员方法的特点： 先查看本类是否有方法如果没有前往父类寻找即就近原则

        2.8.2.1 当父类方法无法满足需求， 子类可以进行方法重写@Override（本质是子类覆盖了虚方法中的方法）

          a. 重写方法的名称、形参列表必须与父类中的一致。

          b. 子类重写父类方法时,访问权限子类必须大于等于父类

          c. 子类重写父类方法时,返回值类型子类必须小于等于父类, 比如父类是A， 子类是B， 然后A中某一个方法返回B类型然后， 子类返回大小也只能是B，假若A中某一个方法返回A类型那么子类大小可以是A或B

          d. 建议:重写的方法尽量和父类保持一致。

          e. 只有被添加到虚方法表中的方法才能被重写

      2.8.3 父类构造方法的特点

        2.8.3.1 构造方法无法继承， 但是子类创建时， 一定会先调用父类的无参构造进行创建

        2.8.3.1 如果想要手动进行父类有参构造可以进行由Super（）进行重写

3. this和super的详解

  3.1 this就是一个局部变量， 当前方法调用者的地址值

  3.2 super就是一个局部变量， 当前方法调用者父类的存储空间

4.多态

  4.1 同类型对象表现出不同形式即 father f=new son1（）

  4.2 多态的前提：

    a. 有继承关系

    b. 有父类引用指向子类对象

    c. 有方法重写

  4.3 多态的调用

    
    口诀：编译看左边， 运行看左边
    a. 成员变量

        如animal a=new Dog(); 而打印其中的name属性时， 假若在animal和Dog中均有name属性， 那么会打印animal中的name， 因为Java中成员变量是静态绑定的， 所以animal类型即会打印animal的name

    口诀： 编译看左边， 运行看右边
    b. 成员方法

         如animal a=new Dog(); 当调用show（）方法时，  假若在animal和Dog中均有show方法， 且Dog对show（）进行了重写， 因为虚方法表中重写会覆盖， 所以会调用Dog中的show（）方法

    4.4 多态优点：

      4.4.1  解耦合， 便于拓展和维护

      4.4.2 定义方法的时候以父类作为参数类型， 既可以将子类传入， 体现了拓展性

    为什么只能由父类被赋值成子类不可以反过来？

    这其实与隐式转换有关， 在之前我们知道隐式转换只能小等于大， 而在继承关系的父与子中， 父类是小于子类的， 所以不能反过来

    如果如animal a=new Dog(); （弊端，多态中不能使用特有功能）其中我想要调用Dog中的方法， 但是会报错因为编译看左边， 运行看右边， 那该怎么解决？

      这种情况我们可以通过强转来解决， 值得一提判断一个变量是否是一直类型， 如果是就强转可以用 instanceof  其中 a instance of Dog d  代表的含义就是先判断a是否是Dog类型如果是强转为d


5.  导包的规则
    
    使用同一个包中的类时,不需要导包。

    使用java.lang包中的类时,不需要导包。

    其他情况都需要导包

    如果同时使用两个包中的同名类,需要用全类名。


6. final

    可以修饰类（不能被继承）， 



    方法（不能被重写）， 



    变量（常量）:

    引用数据类型： 地址值不可变， 所存值可变

    基本数据类型： 值不可改变

7. 权限类型

修饰符    同一 个类中    同一个包中其他类    不同包下的子类  不同包下的无关类

private      √ 

空着不写       √             √ 

protected     √              √                  √ 

public        √              √                   √              √


8. 代码块

  8.1 局部代码块

  8.2 构造代码块： 构造方法中重复的代码写在构造代码块中

  8.3 静态代码快： 和构造代码块相似的写法， 需要加static{}， 随着类加载指向， 且只执行一次
    




      
